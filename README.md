## a1 - part 1
* The search problem starts with the initial state that is passed as the argument. Every successor state is a state / board configuration which is 1 move different from current state. The **successor function** returns 9 successor states for each given state, since every row or column can only move 1 way
* The **state space** is all the board configurations that can be obtained from this initial state with any number of moves.
* The **goal state** is the canonical configuration.
* The **cost function** from each given state to a successor state is 1, since we want to record every move, which corresponds to a row shift(left or right) or column shift(up or down).
* Working of the search algorithm **(A star search)** - 
  * The initial state is added to a fringe. 
  * Each state has a 'previous state' and a 'move' variable(problem specific), that specifies the move which was made to reach this state
  * Then a loop is run till either fringe is empty or goal state is reached. 
  * Inside the loop successor states are generated for each item popped from the fringe. The cost of the successor state is cost of current state(item popped from fringe) + 1. 
  * All the successor states which are not already present in the fringe are added to the fringe. If a successor state is already present, then its cost is checked - if cost of item in fringe is greater than cost of current item popped from fringe + 1, then cost of the item in the fringe is updated, alongwith 'previous state' and 'move'
  * The next item popped from the fringe is based on the Fscore or f() which is sum of cost and heuristic function h(). The addition of the heuristic function is done for each item in the fringe before popping out a state.
  * When goal state is reached, algorithm is stopped and current state is passed to reconstruct path logic. The path or steps to reach the current state is retraced using the 'previous state' for every variable. 
 * Code Representation of the Algorithm - 
  * Each state is represented using a Class 'State'.
  * The variables/ attributes in the class are 1.board configuration 2. cameFrom(previous state) 3. Cost - no. of moves till now to reach this state 4. fscore - sum of cost and heuristic function 5. move is the move made from previous state to reach this state.
  * A method called successors takes a state instance, and returns the 9 successor states (4 row moves and 5 column moves)
  * **Heuristic functions used** - 
    * **No. of misplaced tiles** / positions on the board which do not have the same value as required in the goal state. Since goal state will have correct positions, h() will be 0 for goal state, as expected
    * **Manhattan Distance** - For every position on the board, check where the required value is positioned in the current state and add the difference of (column index and row index, e.g, if value 4 is at 3,3 instead of 0,3, then the value at index 0,3 is 3-0 + 3-3 = 3, which means correct value is at a distance of 3. This is done for each index. The we take sum of values at each index. This sum is divided by (no. of rows + no. of columns)/2 - this is because each column move shifts 5 column tiles or 4 row tiles, hence averaging the 2. 
    * The ideal values of every column and every row are created. For e.g the ideal values for column 1 in a 4x5 grid are [1, 6, 11, 16] and row 1 are [1, 2, 3, 4, 5]. This is compared with the actual values in current state. If the column or row do actuals do not match with ideal, 1 is added for each such column or row. For e.g if first column has values [1, 7, 11, 16] instead of [1, 6, 11, 16] then 1 is added. This is done for each column adn each row and value is returned.
  * **Problems faced - Heuristic function**
    * Since heuristic function 3 considers rows and columns as a whole, this was supposed to work better than other 2 functions, however, problem arises when e.g. col1 is moved up or down by 1, then all the 4 rows show inequalities to ideal thus adding 4 to final heuristic value, even though in reality goal state can be reached in 1 move.
    * The heuristic function 2 - Manhattan Distance works best out of the 3 heuristic functions and is also just as simple to calculate as misplaced tiles
  * Simplifications/ Design Decisions - Decided to use Class variable to hold a state and all other attributes to describe it instead of dictionaries to hold mappings from various states to their previous values

## a1 - part 2
* The search problem starts at the start city that is passed as one of the arguments. The **successor function** returns cities which have a segment directly joining it to the current city. The **state space** is all the cities in the city-gps.txt and road-segments.txt files
* The **goal state** is the city passed as the 2nd argument.
* The **cost function** depeneds on the argument 3 passed to the script. If cost-function is 'distance' then, the distance of the segment given in the file is considered while updating the cost to get to every city from the start city. Similarly, if segments, then no. of segments is considered. For time taken, distance/ speedlimit for the segment joining a successor city to its parent/ previous city is considered. For accidents, when the highway name has a I- then a 2 is added in the variable, otherwise 1 is considered
* Working of the search algorithm **(A star search)** - 
  * The initial state is added to a fringe. 
  * Each state has a 'previous state' and a list of neighbors. The successor function considers each of these when a particular city is the current state.
  * Then a loop is run till either fringe is empty or goal state is reached. 
  * Inside the loop successor states are generated for each item popped from the fringe. The cost of the successor state is cost of current state(item popped from fringe) + cost depending on the cost function (distance, segments, timetaken, accidents). 
  * There is a visited list which is maintained, this list makes sure we do not readd a successor city, but only update it. All the successor states which are not already present in the fringe are added to the fringe. If a successor state is already present, then its cost is checked - if cost of item in fringe is greater than cost of current item popped from fringe + cost-function used, then cost of the item in the fringe is updated, alongwith 'previous state'
  * The next item popped from the fringe is based on the Fscore or f() which is sum of cost and heuristic function h(). The addition of the heuristic function is done for each item in the fringe before popping out a state.
  * When goal state is reached, algorithm is stopped and current state is passed to reconstruct path logic. The path or steps to reach the current state is retraced using the 'previous state' for every variable. 
 * **Code Representation of the Algorithm** - 
  * Each state is represented using a class object 'City'. Each City has a reference to a list of Neighbor objects. Neighbor is a class representing the neighboring city, distance to the city, timetaken to reach the neighbor from City, speedlimit on the segment connecting the 2. Neighbor class is used to compute the cost function
  * The variables/ attributes in the class are 1.name 2. cameFrom(previous state) 3. gscore - value of cost-function used 4.Latitude and Longitude as given in the file 4. fscore - sum of cost and heuristic function 5. neighbors - list of Neighbor objects
  * **Heuristic functions used** - 
    * For cost-function 'segments' and 'safe', we chose heuristic value of 0 because minimizing this value depends on the no. of segments and specific type of segments (I- or not) chosen respectively, without depending on the distance or the speed limits
    * For cost-function 'distance', we created 2 heuristic functions heuristic1 and heuristic2 calculating euclidean distance and haversine distance respectively using the longitudes and latitudes of the current city and the end city, thus giving an approximation of straight line distance between the 2. Answers and Formulas links used for these were - 
    * #https://stackoverflow.com/questions/28994289/calculate-euclidean-distance-with-google-maps-coordinates
    * #https://stackoverflow.com/questions/27928/calculate-distance-between-two-latitude-longitude-points-haversine-formula
   
  * **Challenges faced** - Surprisingly, we are getting optimal/ shorter paths without the heuristic function. This might be because of the way we have handled interstate highways, where we are returning heuristic value of 0 if segment name starts with I-.

## a1 - part3 
*  **Initial state** - Initially, the assignment will be such that no. of teams is equal to no. of people who answered the questions. So initial assignment will be  - [m1, m2, m3, ....mn] for n members who answered the questions. This is because there is only one combination of teams where only 1 member is present in every team. Also, from this assignment, the successor function is easier since any successor of such an initial assignment will be having teams with more than 1 person unless the best solution is already found. Another choice could be to make a random assignment and then try to get better ouput from there.
* **State space** - The state space for this problem is all the different ways in which students can be arranged in different groups with maximum size 3. All combinations are valid states, with different costs depending on the constraints
* **Successor Function** - The successor state of any assignment is the list of assignments which are a combination of 1 team merged with every other team. For e.g, if initial assignment is [s1, s2, s3, s4], then the successor states for this assignment are  - [s1-s2, s3, s4], [s1, s2-s3, s4], [s1-s3, s2, s4], [s1-s4, s2, s3], [s1, s2-s4, s3], [s1, s2, s3-s4]. The successor states for [s1-s2, s3, s4] will be [s1-s2-s3, s4], [s1-s2-s4, s3], [s1-s2, s3-s4]...and so on. Since we are generating all possible assignments that can be found from an assignment, we are either incrementally approaching the optimal solution or have found it already.
* **Goal State** - In this problem, since we are trying to minimize the no. of student complaints as much as possible, there is no single goal state. We keep searching for the best solution, outputting the best one so far. The ideal solution would be to find an assignment such that no. of complaints cannot be reduced any further. 
* **Heuristic Function** - Since the goal is to minimize the no. of complaints, we will find the assignment with minimum no. of complaints from the successor states generated and try to build a better assignment if possible from it. No other heuristic functions have been implemented in our solution due to complexity of the current implementation. However, a good heuristic function maybe to find the best assignment from all the assignments which have the minimum cost(no. of complaints). One posible heuristic could be done by identifying assignments where teammember complaints about team size are more - this is because merging teams in such an assignment may reduce the complaints.
* **Implementation Details** - 
  * We have designed a class called teammember, having attribtes to store the 1. teammembers to work with 2. teammembers not to work with 3. team size required 4. actual team the student is present in 5. and a function which calculates the no. of complaints from this teammember comparing the actual team with the desired attributes. 
  * We create a team using a list of teammembers, and an assignment using list of teams. An assignment also has a cost associated with it, which is the sum of complaints of all the teammembers given the current actual teams they are part of. We store the list of assignments generated in 'Fringe' variable, which is used to pop the assignment with minimum cost. 
  * An assignment is passed to a 'GenerateAssignments' method which takes the list of teams and combines them as discussed in **Successor Function** point above, and generates a list of assignments which are added to the 'Fringe'. We call the yield keyword to output an assignment with minimum cost so far every time we generate assignments. This process of adding to Fringe and generating assignments is done till Fringe is empty, which means all possible combinations are exhausted. 
* **Challenges faced** - 
  * Since each student/ teammember has a list of constraints, the problem becomes much more complicated when trying to identify teammembers 1. wanted, 2. not wanted 3.team size in comparison to current team. At various points in our code, there are 3-4 nested loops. For large number of students, solution is not getting generated quickly enough. 
  * Since the size of the teams is variable, and each student has constraints to be satisfied seperately, representation of this abstraction was complicated and we had to create class objects and various utility functions.
